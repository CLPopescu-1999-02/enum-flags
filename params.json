{"name":"Enum-flags","tagline":"Flags for c++ 11 enum classes","body":"# Flags for C++ 11 enum classes\r\n\r\nC++ 11 gives a new type of enums â€” *enum classes*.\r\nThese are strongly typed enumerations, they do not cast implicitly to or from\r\nthe underlying integer type. They also do not leak enumeration values to\r\nenclosing scope (thus the names of this values do not clash and you no longer\r\nneed to prefix/suffix them with something to disambiguate).\r\n\r\nThe only drawback to type safety is you cannot treat variables of *enum class*\r\ntypes as sets of flags. That is because *enum classes* do not cast to integers\r\nand there are no bitwise operators overloads defined for them.\r\n\r\nThis project brings a `flags` class template which:\r\n* does not convert to or from integer types;\r\n* does implicitly convert from enum it was instantiated by;\r\n* does not convert to that enum;\r\n* supports all bitwise operations except for shifts (since shifts are not very\r\n  reasonable for flags);\r\n* explicitly converts to bool (which allows to use it in boolean contexts, like\r\n  in branching or loop conditions);\r\n* provides access to the underlying integer through member functions;\r\n* instantiates only for enum classes.\r\n\r\n## Usage\r\n``` c++\r\nenum class MyEnum { Value1 = 1 << 0, Value2 = 1 << 1 };\r\nusing MyEnums = flags<MyEnum>; // actually this line is not necessary\r\n\r\nauto mask = Value1 | Value2; // set flags Value1 and Value 2\r\nif (mask & Value2) { // if Value2 flag is set\r\n    doSomething();\r\n}\r\n```\r\n\r\n## Description\r\n``` c++\r\ntemplate <class E> class flags;\r\n```\r\nwhere `E` is an enum class.\r\n\r\n### Member types\r\nMember type    |Definition                                                |Notes\r\n---------------|----------------------------------------------------------|---------------------------------------------\r\nenum_type      |The template parameter (E)                                |\r\nunderlying_type|The integer type that is used as representation of `flags`|Equivalent of `std::underlying_type<E>::type`\r\n\r\n### Member functions\r\n\r\n#### Constructors and assignment operators\r\nName                         |Description\r\n-----------------------------|-----------\r\n`flags()`                    |Default contructor (all flags are unset)\r\n`flags(flags::enum_type)`    |Sets flag denoted by the parameter\r\n`flags(const flags&)`        |Copy constructor\r\n`flags(flags&&)`             |Move constructor\r\n`operator=(flags::enum_type)`|Unsets all flags, then sets flag denoted by the parameter\r\n`operator=(const flags&)`    |Copy assignment\r\n`operator=(flags&&)`         |Move assignment\r\n\r\n#### Bitwise operators\r\nAll functions in this group return reference to `flags`, except for `operator~`\r\nwhich returns a new `flags` value.\r\n\r\nName                                          |Description\r\n----------------------------------------------|-----------\r\n<code>operator&#124;=(flags::enum_type)</code>|Bitwise OR with flag denoted by the parameter\r\n<code>operator&#124;=(const flags&)</code>    |Bitwise OR with flags in the parameter\r\n`operator&=(flags::enum_type)`                |Bitwise AND with flag denoted by the parameter`\r\n`operator&=(const flags&)`                    |Bitwise AND with flags in the parameter\r\n`operator^=(flags::enum_type)`                |Bitwise XOR with flag denoted by the parameter\r\n`operator^=(const flags&)`                    |Bitwise XOR with flags in the parameter\r\n`operator~()`                                 |Bitwise negation\r\n\r\n#### Boolean conversions\r\nName             |Description\r\n-----------------|-----------\r\n`operator bool()`|Returns `true` if any of the flags is set\r\n`operator!()`    |Returns `true` if none of the flags is set\r\n\r\n#### Raw access to integer representation\r\nName                                          |Description\r\n----------------------------------------------|-----------\r\n`underlying_value()`                          |Returns integer representation\r\n`set_underlying_value(flags::underlying_type)`|Sets integer representation to new value\r\n\r\n#### Various functions\r\nName         |Description\r\n-------------|-----------\r\n`swap(flags)`|Swaps two `flags` values\r\n\r\n### Nonmember functions\r\n\r\n#### Bitwise operators\r\nAll functions in this group return new `flags` value.\r\n\r\nName                                                           |Description\r\n---------------------------------------------------------------|-----------\r\n<code>operator&#124;(flags, flags)</code>                      |Bitwise OR of two `flags` values\r\n<code>operator&#124;(flags, flags::enum_type)</code>           |Bitwise OR of a `flags` value and a flag denoted by an enum value\r\n<code>operator&#124;(flags::enum_type, flags)</code>           |Bitwise OR of a `flags` value and a flag denoted by an enum value\r\n<code>operator&#124;(flags::enum_type, flags::enum_type)</code>|Bitwise OR of two flags denoted by enum values\r\n`operator&(flags, flags)`                                      |Bitwise AND of two `flags` values\r\n`operator&(flags, flags::enum_type)`                           |Bitwise AND of a `flags` value and a flag denoted by an enum value\r\n`operator&(flags::enum_type, flags)`                           |Bitwise AND of a `flags` value and a flag denoted by an enum value\r\n`operator&(flags::enum_type, flags::enum_type)`                |Bitwise AND of two flags denoted by enum values\r\n`operator^(flags, flags)`                                      |Bitwise XOR of two `flags` values\r\n`operator^(flags, flags::enum_type)`                           |Bitwise XOR of a `flags` value and a flag denoted by an enum value\r\n`operator^(flags::enum_type, flags)`                           |Bitwise XOR of a `flags` value and a flag denoted by an enum value\r\n`operator^(flags::enum_type, flags::enum_type)`                |Bitwise XOR of two flags denoted by enum values\r\n\r\n#### Comparison operators\r\nAll functions in this group return `bool`.\r\n\r\nName                      |Description\r\n--------------------------|-----------\r\n`operator==(flags, flags)`|Compares if two `flags` values are equal\r\n`operator!=(flags, flags)`|Compares if two `flags` values are not equal\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}